import logging
import numpy as np

from .misc import cantor_pairing

############################
# Training data generation #
############################

def gen_batch_shuffle(batch_size, true_edges, true_params, number_of_surfaces):
    ''' 
    Generator that generates training data. False samples are generated by shuffling true edges and parameters independently, thus no new edges are generated.
    
    Parameters:
    * batch_size: how many samples should be generated, int
    * connected_edges: edges of all true samples, ndarray with shape (num_samples, 2)
    * connected_params: track params of all true samples, ndarray with shape (num_samples, num_selected_params)
    * number_of_surfaces: unused
    
    Yields:
    * [ x_start_id, x_target_id, x_params ]  (ndarrays with length batch_size)
    * y (ndarray with length batch_size of numbers [0,1])
    '''
    assert batch_size < len(true_edges)
    assert len(true_edges) == len(true_params)
    
    num_true = batch_size//2
    num_false = batch_size - num_true
    
    while True:
        idxs = np.arange(len(true_edges))
        np.random.shuffle(idxs)
        idxs = idxs[0:num_true]
        
        # True samples
        x_true_edges = true_edges[idxs]
        x_true_params = true_params[idxs]
        y_true = np.ones(num_true)
        
        # False samples, accept for now the possibility, that the shuffling can create a true sample
        x_false_edges = true_edges.copy()
        x_false_params = true_params.copy()
        
        np.random.shuffle(x_false_edges)
        np.random.shuffle(x_false_params)
        
        x_false_edges = x_false_edges[0:num_false]
        x_false_params = x_false_params[0:num_false]
        y_false = np.zeros(num_false)
        
        # Concatenate and shuffle again
        x_edges = np.concatenate([x_true_edges, x_false_edges])
        x_params = np.concatenate([x_true_params, x_false_params])
        y = np.concatenate([y_true, y_false])
        
        assert len(x_edges) == len(x_params) == len(y) == batch_size
        
        # Shuffle
        idxs = np.arange(len(x_edges))
        np.random.shuffle(idxs)
        
        x_edges = x_edges[idxs]
        x_params = x_params[idxs]
        y = y[idxs]
        
        yield ([ x_edges[:,0], x_edges[:,1], x_params ], y)


    
def gen_batch_random(batch_size, true_edges, true_params, number_of_surfaces, edge_transform = lambda e: e):
    ''' 
    Generator that generates training data. False samples are randomly generated edge-pairs, with randomly generated (and normalized) directions. Assumes that the ids which represent the surface are a all natural numbers [0, number_of_surfaces].
    
    Parameters:
    * batch_size: how many samples should be generated, int
    * connected_edges: edges of all true samples, ndarray with shape (num_samples, 2)
    * connected_params: track params of all true samples, ndarray with shape (num_samples, num_selected_params)
    * number_of_surfaces: int
    
    Yields:
    * [ x_start_id, x_target_id, x_params ]  (ndarrays with length batch_size)
    * y (ndarray with length batch_size of numbers [0,1])
    '''
    
    assert batch_size < len(true_edges)
    assert len(true_edges) == len(true_params)
    
    num_true = batch_size//2
    num_false = batch_size - num_true
    
    # increase number of unconnecteds to account for later filtered out edges
    increase = 1.1
    
    while True:
        # true edges
        idxs = np.arange(len(true_edges))
        np.random.shuffle(idxs)
        idxs = idxs[0:num_true]
        
        x_true_edges = true_edges[idxs]
        x_true_params = true_params[idxs]
        y_true = np.ones(num_true)
        
        # false edges (randomly sampled integers which represent surfaces)
        x_false_edges = np.random.randint(0,number_of_surfaces,(int(num_false*increase),2))
        x_false_edges = np.unique(x_false_edges,axis=0)
        
        is_false_edge_mask = np.logical_not(np.isin(cantor_pairing(x_false_edges),cantor_pairing(true_edges),assume_unique=True))
        is_no_loop_mask = x_false_edges[:,0] != x_false_edges[:,1]
        is_valid_mask = np.logical_and(is_false_edge_mask, is_no_loop_mask)
        
        x_false_edges = x_false_edges[is_valid_mask]
        
        if len(x_false_edges) < num_false:
            logging.warning("continue was necessary in generator")
            continue
        
        # Create set of unconnected edges
        x_false_edges = x_false_edges[0:num_false]
        
        x_false_params = np.random.uniform(-1,1,(num_false,3))
        for direction in x_false_params:
            direction /= np.linalg.norm(direction)
        
        y_false = np.zeros(num_false)
        
        # Combine
        x_edges = np.concatenate([x_true_edges,x_false_edges])
        x_params = np.concatenate([x_true_params, x_false_params])
        y = np.concatenate([y_true,y_false])
        
        assert len(x_edges) == len(x_params) == len(y) == batch_size
        
        # Shuffle
        idxs = np.arange(len(x_edges))
        np.random.shuffle(idxs)
        
        x_edges = x_edges[idxs]
        x_params = x_params[idxs]
        y = y[idxs]
        
        yield ([ edge_transform(x_edges[:,0]), edge_transform(x_edges[:,1]), x_params ], y)




def gen_batch_rotate(batch_size, true_edges, true_params, number_of_surfaces):
    ''' 
    Generator that generates training data. False samples are generated by shuffling true edges and parameters independently, thus no new edges are generated.
    
    Parameters:
    * batch_size: how many samples should be generated, int
    * connected_edges: edges of all true samples, ndarray with shape (num_samples, 2)
    * connected_params: track params of all true samples, ndarray with shape (num_samples, num_selected_params)
    * number_of_surfaces: unused
    
    Yields:
    * [ x_start_id, x_target_id, x_params ]  (ndarrays with length batch_size)
    * y (ndarray with length batch_size of numbers [0,1])
    '''
    assert batch_size < len(true_edges)
    assert len(true_edges) == len(true_params)
    
    num_true = batch_size//2
    num_false = batch_size - num_true
    
    while True:
        idxs = np.arange(len(true_edges))
        np.random.shuffle(idxs)
        idxs = idxs[0:num_true]
        
        # True samples
        x_true_edges = true_edges[idxs]
        x_true_params = true_params[idxs]
        y_true = np.ones(num_true)
        
        # False samples, accept for now the possibility, that the shuffling can create a true sample
        x_false_edges = true_edges.copy()
        x_false_params = true_params.copy()
        
        np.random.shuffle(x_false_edges)
        np.random.shuffle(x_false_params)
        
        x_false_edges = x_false_edges[0:num_false]
        x_false_params = x_false_params[0:num_false]
        y_false = np.zeros(num_false)
        
        # Concatenate and shuffle again
        x_edges = np.concatenate([x_true_edges, x_false_edges])
        x_params = np.concatenate([x_true_params, x_false_params])
        y = np.concatenate([y_true, y_false])
        
        assert len(x_edges) == len(x_params) == len(y) == batch_size
        
        # Shuffle
        idxs = np.arange(len(x_edges))
        np.random.shuffle(idxs)
        
        x_edges = x_edges[idxs]
        x_params = x_params[idxs]
        y = y[idxs]
        
        yield ([ x_edges[:,0], x_edges[:,1], x_params ], y)
        
        
        
        
if __name__ == "__main__":
    
    
    vec = np.random.uniform(-1,1,3)
    
    
    vec2 = np.random.uniform(-1,1,3)
    vec2[2] = 0
    
    
    alpha = np.pi/6
    
    
    # solve
    
    
    a = vec.dot(vec2)
    b = vec[2]
    c = vec2.dot(vec2)
    d = np.cos(alpha)*np.sqrt(vec.dot(vec))
    
    x = (d * np.sqrt(a**2 + c*(b**2 - d**2)) - a*b) / (b**2 - d**2)
    
    vec2[2] = x
    
    
    # test
    def unit_vector(vector):
        return vector / np.linalg.norm(vector)

    def angle_between(v1, v2):
        v1_u = unit_vector(v1)
        v2_u = unit_vector(v2)
        return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))
    
    print("alpha = ",alpha)
    print("sol = ", angle_between(vec, vec2) )
    
    
    
    
