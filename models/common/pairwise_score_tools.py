import logging
import numpy as np

from .misc import cantor_pairing

############################
# Training data generation #
############################

def gen_batch_shuffle(batch_size, true_edges, true_params, number_of_surfaces):
    ''' 
    Generator that generates training data. False samples are generated by shuffling true edges and parameters independently, thus no new edges are generated.
    
    Parameters:
    * batch_size: how many samples should be generated, int
    * connected_edges: edges of all true samples, ndarray with shape (num_samples, 2)
    * connected_params: track params of all true samples, ndarray with shape (num_samples, num_selected_params)
    * number_of_surfaces: unused
    
    Yields:
    * [ x_start_id, x_target_id, x_params ]  (ndarrays with length batch_size)
    * y (ndarray with length batch_size of numbers [0,1])
    '''
    
    num_true = batch_size//2
    num_false = batch_size - num_true
    
    while True:
        idxs = np.arange(len(true_edges))
        np.random.shuffle(idxs)
        idxs = idxs[0:num_true]
        
        # True samples
        x_true_edges = true_edges[idxs]
        x_true_params = true_params[idxs]
        y_true = np.ones(num_true)
        
        # False samples, accept for now the possibility, that the shuffling can create a true sample
        x_false_edges = true_edges.copy()
        x_false_params = true_params.copy()
        
        np.random.shuffle(x_false_edges)
        np.random.shuffle(x_false_params)
        
        x_false_edges = x_false_edges[0:num_false]
        x_false_params = x_false_params[0:num_false]
        y_false = np.zeros(num_false)
        
        # Concatenate and shuffle again
        x_edges = np.concatenate([x_true_edges, x_false_edges])
        x_params = np.concatenate([x_true_params, x_false_params])
        y = np.concatenate([y_true, y_false])
        
        assert len(x_edges) == len(x_params) == len(y) == batch_size
        
        # Shuffle
        idxs = np.arange(len(x_edges))
        np.random.shuffle(idxs)
        
        x_edges = x_edges[idxs]
        x_params = x_params[idxs]
        y = y[idxs]
        
        yield ([ x_edges[:,0], x_edges[:,1], x_params ], y)


    
def gen_batch_random(batch_size, true_edges, true_params, number_of_surfaces, edge_transform = lambda e: e):
    ''' 
    Generator that generates training data. False samples are randomly generated edge-pairs, with randomly generated (and normalized) directions. Assumes that the ids which represent the surface are a all natural numbers [0, number_of_surfaces].
    
    Parameters:
    * batch_size: how many samples should be generated, int
    * connected_edges: edges of all true samples, ndarray with shape (num_samples, 2)
    * connected_params: track params of all true samples, ndarray with shape (num_samples, num_selected_params)
    * number_of_surfaces: int
    
    Yields:
    * [ x_start_id, x_target_id, x_params ]  (ndarrays with length batch_size)
    * y (ndarray with length batch_size of numbers [0,1])
    '''
    
    num_true = batch_size//2
    num_false = batch_size - num_true
    
    # increase number of unconnecteds to account for later filtered out edges
    increase = 1.1
    
    while True:
        # true edges
        idxs = np.arange(len(true_edges))
        np.random.shuffle(idxs)
        idxs = idxs[0:num_true]
        
        x_true_edges = true_edges[idxs]
        x_true_params = true_params[idxs]
        y_true = np.ones(num_true)
        
        # false edges (randomly sampled integers which represent surfaces)
        x_false_edges = np.random.randint(0,number_of_surfaces,(int(num_false*increase),2))
        x_false_edges = np.unique(x_false_edges,axis=0)
        
        is_false_edge_mask = np.logical_not(np.isin(cantor_pairing(x_false_edges),cantor_pairing(true_edges),assume_unique=True))
        is_no_loop_mask = x_false_edges[:,0] != x_false_edges[:,1]
        is_valid_mask = np.logical_and(is_false_edge_mask, is_no_loop_mask)
        
        x_false_edges = x_false_edges[is_valid_mask]
        
        if len(x_false_edges) < num_false:
            logging.warning("continue was necessary in generator")
            continue
        
        # Create set of unconnected edges
        x_false_edges = x_false_edges[0:num_false]
        
        x_false_params = np.random.uniform(-1,1,(num_false,3))
        for direction in x_false_params:
            direction /= np.linalg.norm(direction)
        
        y_false = np.zeros(num_false)
        
        # Combine
        x_edges = np.concatenate([x_true_edges,x_false_edges])
        x_params = np.concatenate([x_true_params, x_false_params])
        y = np.concatenate([y_true,y_false])
        
        assert len(x_edges) == len(x_params) == len(y) == batch_size
        
        # Shuffle
        idxs = np.arange(len(x_edges))
        np.random.shuffle(idxs)
        
        x_edges = x_edges[idxs]
        x_params = x_params[idxs]
        y = y[idxs]
        
        yield ([ edge_transform(x_edges[:,0]), edge_transform(x_edges[:,1]), x_params ], y)
